import datetime
import re
from decimal import Decimal

from django.db import models
from django.utils.translation import ugettext as _
from django.conf import settings

from actor.models import Actor
from sproductinfo.models import Product
# from fixido.util import make_uuid

BASKET_STATUS = (
    ('active', 'Active'),
    ('inactive', 'InActive'),
    ('deleted', 'Deleted'),
    ('order', 'Order'),
    ('saved', 'Saved'),
)

ORDER_FLAG = (
    ('none', 'None'),
    ('processing', 'Processing'),
    ('paid', 'Paid'),
    ('wait', 'Wait'),
    ('error', 'Error'),
)

ORDER_TYPE = (
    ('actor', 'Actor'),
    ('aec', 'AEC'),
    ('api', 'API'),
    ('basket', 'Basket'),
    ('bidding', 'Bidding'),
    ('campaign', 'Campaign'),
    ('direct', 'Direct'),
)

TRANSACTION_FLAG = (
    ('none', 'None'),
    ('processing', 'Processing'),
    ('paid', 'Paid'),
    ('wait', 'Wait'),
    ('error', 'Error'),
)

TRANSACTION_TYPE= (
    ('order', 'Order'),
    ('deposit', 'Deposit'),
    ('payout', 'Payout'),
    ('voucher', 'Voucher'),
    ('invite', 'Invite'),
    ('sales', 'Sales'),
    ('commission', 'Commission'),
    ('kickback', 'Kickback'),
    ('signupbonus', 'Signup Bonus'),
#    ('paypal', 'Paypal'),
    ('refund', 'Refund'),
    ('credit', 'Credit'),
    ('invoice', 'Invoice'),
    ('expired', 'Expired'),
)

TRADE_STATUS = (
    ('none', 'None'),
    ('processing', 'Processing'),
    ('paid', 'Paid'),
    ('wait', 'Wait'),
    ('error', 'Error'),
)

INVOICE_FLAG = (
    ('none', 'None'),
    ('creating', 'Creating'),
    ('sent', 'Sent'),
    ('paid', 'Paid'),
    ('reminder1', 'Reminder 1'),
    ('reminder2', 'Reminder 2'),
    ('credit', 'Credit'),
    ('cancel', 'Cancel'),
    ('error', 'Error'),
)


class Basket(models.Model):
  """
  Basket handles the overall information until order is finished in the checkout process
  One basket connects to an actor. (there is no anonymous users)
  There can only be ONE active basket at a time per actor. All other baskets should be archived with other status.
  """
  
  actor = models.ForeignKey(Actor)
  #TODO: Compute this field automatic from BasketLines. NOTE CURRENCYS!!!
  total = models.DecimalField(default=0.0, max_digits=10, decimal_places=2, help_text="Total value of items in basket (excluding TAX)")
  total_currency = models.CharField(max_length=8, default=settings.BASE_CURRENCY, null=True, blank=True, help_text="Basket currency. Stored as ISO codes (SEK, EUR, etc) in the DB")
  total_tax = models.DecimalField(default=0.0, max_digits=10, decimal_places=2, help_text="Total tax of the item")
  
  #TODO: Compute this field automatic from BasketLines.
  total_quantity = models.FloatField(default=0.0, help_text="Total number of items in basket")
  
  active = models.BooleanField(default=True, help_text="Basket status, handle by system")
  status = models.CharField(max_length=10, default='active', choices=BASKET_STATUS, help_text="Basket status, handle by actor. Default is 'Active'. There can only be ONE active basket at a time per actor. All other baskets should be archived with other status")

  created = models.DateTimeField(auto_now_add=True, help_text="Auto generated by system.")
  modified = models.DateTimeField(auto_now_add=True, auto_now=True, help_text="Auto generated by system.")


  @classmethod
  def get_actor_basket(cls, actor, basket=None, basket_lines=None):
    """Returns dict of values about basket, basket-line and total"""

    from logic import calculate_vat

    # basket = None
    # basket_lines = None
    sub_total = 0
    vat_total = 0
    total = 0
    vat_percent = 0
    vat_number = None
    actor_country = None
    currency = actor.currency
    invalid_leads = []
    unavailable_leads = []
    products = []

    if basket is None:
      baskets = cls.objects.filter(actor=actor, status='active')[:1]
      if baskets:
        basket = baskets[0]

    if basket:
      basket_lines = basket_lines or BasketLine.objects.filter(basket=basket).prefetch_related('product')[:]
      print 'here', basket_lines
      sub_total1 = 0
      sub_total = 0
      
      for line in basket_lines:
        print 'product=>', line.product
        product = line.product

        if line.product.product_price:
          sub_total1 = line.product.product_price * line.quantity
          sub_total += sub_total1
        
        products.append(product)

        # available = lead.available()
        # if available < line.quantity:
        #   unavailable_leads.append( (lead, available) )

        # if not lead.isactive():
        #   invalid_leads.append(lead)

      # actor_country, vat_number = actor.get_country_vat()
      # vat_total = calculate_vat(sub_total, actor_country)
      # vat_percent = calculate_vat(1, actor_country, vat_number)
      total = sub_total + vat_total

    return dict(basket=basket, basket_lines=basket_lines, sub_total=sub_total, vat_total=vat_total, total=total, vat_percent=vat_percent, 
      # actor_country=actor_country, currency=currency, vat_number=vat_number,
      # invalid_leads=invalid_leads, unavailable_leads=unavailable_leads
      )


  # @classmethod
  # def create_dummy_basket(cls, lead, actor, bid_price=None, is_free=False):

  #   basket = Basket(actor=actor)
  #   line = BasketLine(basket=basket, quantity=1, lead=lead)
  #   line.bid_price = bid_price
  #   line.bid_currency = actor.currency
  #   line.is_free_item = is_free

  #   return cls.get_actor_basket(actor, basket, [line])

  def __unicode__(self):
    return str(self.created)


class BasketLine(models.Model):
  """
  Basket line handles the items in the basket
  """ 
  basket = models.ForeignKey(Basket)
  product = models.ForeignKey(Product)  
  quantity = models.IntegerField(default=1, null=False, help_text="Number of items in the basket line. Default is 1.")
  created = models.DateTimeField(auto_now_add=True, help_text="Auto generated by system.")
  modified = models.DateTimeField(auto_now_add=True, auto_now=True, help_text="Auto generated by system.")
    
  def __unicode__(self):
    return str(self.created)
